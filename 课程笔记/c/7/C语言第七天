
#include <string.h>

strlen   字符串长度函数
size_t strlen(const char *s);
功能:计算字符串的长度,到字符串'\0'截止
返回值:size_t(unsigned int)  返回字符串的实际长度,不计算'\0'长度

strcpy   字符串拷贝函数
char *strcpy(char *dest, const char *src);
功能:将源字符串src拷贝到目标字符串dest中,连同'\0'一同拷贝
返回值:dest存储的首地址
注:
1.会对dest的内容进行覆盖,并且dest不能是字符串常量!!!!
2.需要保证dest的空间足够大,不然会出现数组越界
3.不能进行字符串的自拷贝

strcat   字符串拼接函数
char *strcat(char *dest, const char *src);
功能:把源字符串src,连接到目标字符串dest的末尾
返回值:dest存储的首地址
注:
1.src会把dest末尾的'\0'覆盖,并把自己的'\0'带过去
2.保证dest的空间足够大,以及dest不能是字符串常量

strcmp  字符串比较函数
int strcmp(const char *s1, const char *s2);
功能:逐字比较两个字符串s1和s2,本质是比较两个字符串的ascii码是否相同
当遇到'\0'或者两边字符不一样时返回结果
返回值:
当s1 > s2 时  返回正整数  1
当s1 < s2 时  返回负整数  -1
当s1 == s2 时  返回0


地址:
指针:
指针变量:

内存以一个字节(byte)为单位进行划分,并对每一个字节进行编号,
所谓的内存编号,这个内存编号也就是每一个字节对应的地址


&(取地址符):取出地址    例如:int a   &a:获取变量a的首地址(开始的位置)
*(指针运算符):取地址里的值进行操作
例如:
int a
int *p = &a;
p == &a
*p == *(&a) == a

指针:
数据类型  * 指针变量名;
注:
1.指针变量用来存放地址
2.数据类型   (是指针指向数据的数据类型)
例如:
int a = 10;
int *p = &a;
指针p指向a的首地址
指针变量p存放了a的首地址
指针 == 指针变量

直接引用
间接引用:指针操作基本都是间接引用

指针初始化:
野指针:没有明确指向的指针
如果对野指针进行操作会出现段错误
Segmentation fault (core dumped)

空指针:
int *p = NULL;
NULL  编号为0的地址空间,NULL受到系统保护,不能对NULL进行修改,如果修改会出现段错误
Segmentation fault (core dumped)

段错误调试:
gdb调试工具:
gcc -g 出现段错误的程序.c
gdb ./a.out
r
错误信息这时候显示
q  退出
y

指针运算
例如:int *p;
+
p+1:
地址值+1不是数值+1, 是指地址的值向高地址方向偏移了对应数据类型(指针指向数据的数据类型)大小
指针p的指向没有发生改变

-
p-1:

++
p++:  p = p+1  指针p往高地址方向偏移了一个数据类型(指针指向数据的数据类型)大小
++p

p-q:指针p,q必须指向同一片连续的空间,且该空间内数据类型保持一致,运算的结果为相差数据的个数

p>q:比较的是地址值的大小

指针的数据类型
int *
char *
short *
注:无论什么形式的指针类型,大小永远为4个字节(32位系统地址的值是8位16进制数对应4个字节)

一维数组与指针

注:
1.一维数组的数组名是数组的首地址
2.数组名还能表示整个数组,比如int a[6],sizeof(a)

例如:
int a[6]
一维数组中数组名就是数组的首地址，数组名是一个地址常量，不能自加。
所以a == &a[0]
a+1 == &a[0]+1 == &a[1]
*(a+1) == *(&a[0]+1) == *(&a[1]) == a[1]
得到:
*(a+n) == a[n]
当指针p指向数组a时,指针指向的是数组a的首地址(或者说是数组的首元素地址&a[0])
int *p = a;// &a[0]
得到:
p == a == &a[0]
p+1 == a+1 == &a[1]
*(p+1) == *(a+1) == *(&a[1]) == a[1] == p[1]
最终得到数组与指针关系
*(a+n) == *(p+n) == a[n] == p[n]

数组指针:本质是指针指向整个数组空间
例如:
int a[6];
int (*p) [6] = &a;   这是a代表整个数组,而不是数组首地址
注:
1.(*p) 要加括号
2.&a获取的是整个数组空间的地址   p和&a的数据类型int (*)[6]
