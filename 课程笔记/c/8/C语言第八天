
#include <string.h>

strlen   字符串长度函数
size_t strlen(const char *s);
功能:计算字符串的长度,到字符串'\0'截止
返回值:size_t(unsigned int)  返回字符串的实际长度,不计算'\0'长度

strcpy   字符串拷贝函数
char *strcpy(char *dest, const char *src);
功能:将源字符串src拷贝到目标字符串dest中,连同'\0'一同拷贝
返回值:dest存储的首地址
注:
1.会对dest的内容进行覆盖,并且dest不能是字符串常量!!!!
2.需要保证dest的空间足够大,不然会出现数组越界
3.不能进行字符串的自拷贝

strcat   字符串拼接函数
char *strcat(char *dest, const char *src);
功能:把源字符串src,连接到目标字符串dest的末尾
返回值:dest存储的首地址
注:
1.src会把dest末尾的'\0'覆盖,并把自己的'\0'带过去
2.保证dest的空间足够大,以及dest不能是字符串常量

strcmp  字符串比较函数
int strcmp(const char *s1, const char *s2);
功能:逐字比较两个字符串s1和s2,本质是比较两个字符串的ascii码是否相同
当遇到'\0'或者两边字符不一样时返回结果
返回值:
当s1 > s2 时  返回正整数  1
当s1 < s2 时  返回负整数  -1
当s1 == s2 时  返回0


地址:
指针:
指针变量:

内存以一个字节(byte)为单位进行划分,并对每一个字节进行编号,
所谓的内存编号,这个内存编号也就是每一个字节对应的地址


&(取地址符):取出地址    例如:int a   &a:获取变量a的首地址(开始的位置)
*(指针运算符):取地址里的值进行操作
例如:
int a
int *p = &a;
p == &a
*p == *(&a) == a

指针:
数据类型  * 指针变量名;
注:
1.指针变量用来存放地址
2.数据类型   (是指针指向数据的数据类型)
例如:
int a = 10;
int *p = &a;
指针p指向a的首地址
指针变量p存放了a的首地址
指针 == 指针变量

直接引用
间接引用:指针操作基本都是间接引用

指针初始化:
野指针:没有明确指向的指针
如果对野指针进行操作会出现段错误
Segmentation fault (core dumped)

空指针:
int *p = NULL;
NULL  编号为0的地址空间,NULL受到系统保护,不能对NULL进行修改,如果修改会出现段错误
Segmentation fault (core dumped)

段错误调试:
gdb调试工具:
gcc -g 出现段错误的程序.c
gdb ./a.out
r
错误信息这时候显示
q  退出
y

指针运算
例如:int *p;
+
p+1:
地址值+1不是数值+1, 是指地址的值向高地址方向偏移了对应数据类型(指针指向数据的数据类型)大小
指针p的指向没有发生改变

-
p-1:

++
p++:  p = p+1  指针p往高地址方向偏移了一个数据类型(指针指向数据的数据类型)大小
++p

p-q:指针p,q必须指向同一片连续的空间,且该空间内数据类型保持一致,运算的结果为相差数据的个数

p>q:比较的是地址值的大小

指针的数据类型
int *
char *
short *
注:无论什么形式的指针类型,大小永远为4个字节(32位系统地址的值是8位16进制数对应4个字节)

一维数组与指针

注:
1.一维数组的数组名是数组的首地址
2.数组名还能表示整个数组,比如int a[6],sizeof(a)

例如:
int a[6]
一维数组中数组名就是数组的首地址,且数组名是地址常量,不能随意改变
所以a == &a[0]
a+1 == &a[0]+1 == &a[1]
*(a+1) == *(&a[0]+1) == *(&a[1]) == a[1]
得到:
*(a+n) == a[n]
当指针p指向数组a时,指针指向的是数组a的首地址(或者说是数组的首元素地址&a[0])
int *p = a;// &a[0]
得到:
p == a == &a[0]
p+1 == a+1 == &a[1]
*(p+1) == *(a+1) == *(&a[1]) == a[1] == p[1]
最终得到数组与指针关系
*(a+n) == *(p+n) == a[n] == p[n]

数组指针:本质是指针指向整个数组空间
例如:
int a[6];
int (*p) [6] = &a;   这是a代表整个数组,而不是数组首地址
注:
1.(*p) 要加括号
2.&a获取的是整个数组空间的地址   p和&a的数据类型int (*)[6]

二维数组和指针
例如:
int a[3][4] ---- > int [4] a[3]
a == &a[0]   a[0]是int[4]
a+1 == &a[0]+1 == &a[1]
*(a+1) == a[1]     a[1]  int [4]  取出的是一整行  a[1]代表一整行也就是相当于数组名

int a[1]   [4]
a[1] == &a[1][0]
a[1]+1 == &a[1][0]+1 == &a[1][1]

*(a[1]+1) == a[1][1]
*(*(a+1)+1) == a[1][1]
得到:
*(*(a+i)+j) = a[i][j]

当
int (*p)[4] = a;
p == a
得到:
*(*(p+i)+j) == p[i][j]

注:二维数组的数组名需要用数组指针才能接收,本质指针p指向的是数组a的首行

字符指针:
char a = 'A';
char *p = &a;

在字符指针初始化时可以通过字符串进行初始化
char *p = "hello";  将字符串的首地址赋予字符指针

printf %s是从字符串的首地址打印直接'\0'结尾
注:
1.字符指针不能去修改字符串常量
2.字符数组可以将存储在内的字符串进行修改(该字符串已经是拷贝过来的副本)

void型指针
void *p   能接收一切指针类型的地址和指针变量
但是当进入运算时需要将类型还原

二级指针:
一个指针指向另一个指针
int a = 10;
int *p = &a;
int **q = &p;

q == &p
*q == *(&p) == p == &a
**q == *p == a

const:把变量常量化
const int a = 10;

例如:
int a = 10;
int * p = &a;

int * const p :
修饰p,p空间里面的地址值不能通过名字p来修改,p的指向不能发生改变,*p可以修改

int const *p :
修饰*p,不能通过指针p对指向的数据进行修改,p的指向可以改变
const int *p : 同上

const int * const p:
*p和p都被修饰,指不能改变p的指向,也不能通过*p修改指向数据的内容


指针数组:
本质是数组,里面存放的时指针类型数据

指针类型  数组名[下标]

int *p[3]   指针数组,本质是数组,数组有三个元素都为int *型
int (*p)[3] 数组指针,本质是指针,该指针指向一个大小为int [3]的数组空间

如果用一个指针指向指针数组的首地址,那么这个指针是一个二级指针

数组指针数组:详细看zhizhenshuzu2.c
本质是数组,里面存放的数组指针类型
