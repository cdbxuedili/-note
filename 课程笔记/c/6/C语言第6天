数组:
1.构造类型
2.数组是若干个变量的有序集合,数组内的每一个变量也叫作数组的元素
3.数组内的变量(元素)要求数据类型一致

一维数组:
一般形式:
存储类型 数据类型  数组名[下标]
            |              |
        数组内元素   标注了数组
        的数据类型   内元素的个数

如何引用(表示)数组内的每一个成员:
数组名[下标]   --->下标从0开始
例如:
int a[10]        第一个成员为a[0],最后一个成员为a[9] (注:没有a[10]!!!越界问题)
需要快速引用数组成员时可以选择for循环遍历数组下标的形式

注:数组在内存上存放数据时是连续不间断的线性的排布

数组的初始化:
完全初始化:数组定义时对数组内的每个成员赋初值
例如:
int a[6] = {2,2,2,2,2,2};

不完全初始化:
注:当数组内有一个成员在初始化被赋值时,其他成员就算没有初始化,默认为0
例如:
int b[6] = {2,2,2};

static数组:不需要初始化,里面所有元素默认为0

数组赋值错误演示:
int a[10];
a = {1,2,3,4,5,6,7,8,9,10};
错误:原因数组名是地址常量,常量不能修改

数组的数据类型:构造类型
例如:int a[10]
数据类型:int [10]
数据类型大小: 元素的数据类型x下标(数组内元素个数)

错误:见shuzu7.c
正确:见shuzu8.c

数组越界是错误!!!但是程序编译一般不报错,如果报错为Segmentation fault (core dumped)
段错误:核心已转储

冒泡排序:
一轮确定一个数,确定n个数需要n-1轮
每一轮中进行两两比较,大的数往右放,比较的次数会受到轮数的限制

简单选择排序:
一轮确定一个数,确定n个数需要n-1轮
假设最大值,与后面的数进行比较,记录下正真的最大值下标,一轮结束后假设值与正真最大值进行交换

二维数组:
一般形式:
存储类型 数据类型 数组名[行标][列标]  ---- > 行x列 == 数组内元素个数
            |
         数组内元素的数据类型

如何引用二维数组内的成员:数组名[行标][列标]   行标与列标都是从0开始
例如int a[3][4]     第一个元素a[0][0]    a[2][3]

注:由于内存是线性的(一维),所以二维数组存放在内存上时,需要转化成一维存放,所谓的行序优先

二维数组的初始化:
完全初始化
例如:两者没有区别
int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
int a1[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

不完全初始化
例如:两者有区别
int b[3][4] = {{1,2},{3,4},{5,6}};  1 2 0 0 /3 4 0 0/5 6 0 0
int b1[3][4] = {1,2,3,4,5,6};   1 2 3 4/5 6 0 0/0 0 0 0
二维数组书写时,可以省略行标,但不能省略列标

二维数组的大小:行x列x元素数据类型大小

gets 字符串输入函数
char *gets(char *s);
功能:从键盘获取一串以回车为结束标志的字符串
注:
1.gets会在字符串末尾自动加'\0'
2.gets使用时需要注意接收字符串的字符数组大小是否足够,不然可能造成数组越界
3.与scanf函数不同,gets函数能够把space作为字符吃入字符串

puts 字符串输出函数
int puts(const char *s);
功能:向屏幕输出字符串
注:puts会自动在字符串末尾加'\n'
本质:从字符串开始打印知道末尾'\0'截止

字符数组:
一般形式:
char 数组名[下标]
例如:
char a[] = "hello";
char a1[] = {"hello"};
char a2[] = {'h','e','l','l','o','\0'};
以上三种均为字符数组的初始化过程,里面都是hello字符串
char a3[] = {'h','e','l','l','o'};
别名ascii码数组,里面没有'\0',不是字符串

初始化:可以直接通过字符串对字符数组初始化 注:字符串末尾有'\0'
打印字符串的方式:printf %s   puts   都是以'\0'为界限

作业:
