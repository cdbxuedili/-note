shell脚本――能看懂、Makefile――必须要会、配置tftp和nfs――系统移植和驱动中每天都要用

shell脚本的本质:shell命令的有序集合

shell脚本属于解释型语言，c属于编译型语言。无论哪种语言执行时都需要将其变成二进制。
c代码由编译器转换成二进制
脚本由解释器转换成二进制
linux环境:常用一些解释器有bash、sh、dash等等。

如何执行脚本文件？
有四种方法:
1、将脚本文件权限变成777权限，chmod 777 1.sh 
	./1.sh 
	
2、解释器 1.sh 
以上两种方法:都是创建了子脚本，结果由子脚本操作，不会看到路径改变 

3、source 1.sh 执行脚本文件 
4、. ./1.sh 
后面两种方法，执行结果就是当前脚本本身操作的。

数据类型 变量名;
脚本中没有数据类型,一切变量存放的值本质都是字符串。
脚本中定义变量时必须初始化。
变量名=内容    注意:内容可以有可以没有，但是=必须要存在
				    =的左右不能有空格

打印脚本变量时:
1、用户自定义变量:
如果字符串中有空格，并且要将其输出，则调用echo "$变量名"
如果字符串中没有空格或者说不需要输出空格，则调用echo $变量名
当变量需要去构成表达式时需要加{}
如果一个命令的结果作为变量内容，则在命令外加``	命令置换符

2、环境变量:系统定义好并且初始化的变量，我们只需要引用。
常用的环境变量:
HOME――家目录的绝对路径  
PATH存放的是一堆路径，这堆路径都是用来操作shell命令的 

对PATH的操作:
export PATH=$PATH:/home/linux/gcc-4.6.4/bin 
作用:在PATH原有内容的后面新增一个路径
export PATH=/home/linux/gcc-4.6.4/bin:$PATH
作用:在PATH原有内容的前面新增一个路径

export PATH=$PATH:/home/linux/gcc-4.6.4/bin 为例:
这句话其实是由两句话组成
PATH=$PATH:/home/linux/gcc-4.6.4/bin 功能只适用于当前文件
export PATH 系统中所有的相关配置文件都可以默认使用（导出当前局部变量为全局变量）

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库的绝对路径
放在一个配置文件中/etc/bash.bashrc
最后在使用source 来重启配置文件

3、位置变量:
$0 脚本文件名
$1 - $9 脚本文件名后面传递的参数
$# 参数的个数，从$1开始算
$? 代表的是上一条命令的执行状态，0代表成功或者1代表失败

cat passwd | cut -d ':' -f 1 | grep "^linux$" -n | cut -d ':' -f 1  显示出34行
cat passwd | head -34 | tail -1 显示出第34行的所有内容


cat passwd | head -`cat passwd | cut -d ':' -f 1 | grep "^linux$" -n | cut -d ':' -f 1` | tail -1

#!/bin/bash 说明当前脚本使用的是bash命令行解释器

shell脚本中的最难的地方:正则表达式
string=abcdef1234abcdefabcd
注意:表达式不是命令，所以赋值时如果只是使用表达式，则不需要使用命令置换符
${string//abcd/xy} 将所有的abcd替换成xy

${string/abcd/xy}
替换的是第一个字符串abcd
 
${string/#abcd/xy}
替换的是字符串的开头，如果abcd不是开头则原样输出

${string/%abcd/xy} 
替换的是字符串的结尾，如果abcd不是结尾则原样输出
 
${string:3}
去掉前3个字符，取出后面所有内容
${string:3:5}
去掉前三个字符，然后取出后面5个字符

${string#abcd}
去掉自符串开头

${string#abcd*ef}
去掉从头开始到第一个ef的部分

${string##abcd*ef}
去掉从头开始到最后一个ef的部分

${string%abcd}
如果abcd是尾部，直接去掉

${string%ef*}
去掉最后的ef以及ef后面的所有内容

${string%%ef*}
去掉第一个ef以及ef后面的所有内容

test语句:必须掌握,为了测试字符串在判断条件中是否成立的。
test可以检测字符串、整数、文件名――都是字符串，看使用上下文

普通字符串:
如果符号是=或者!=
test "$变量" 符号 "字符串"
如果是-z(判断字符串长度是否为0)或者-n(判断字符串长度是否不为0) 
test 符号 "$变量"

假设test "$string" = "hello",判断string的内容和hello是否相等。
如何能知道相等了? 
通过$?的结果来判断是否成立

操作整数:-eq -ne -le -lt -ge -gt 

操作文件名:
-f 判断是否为普通文件
-d 判断是否为目录文件
-L 判断是否为软链接文件
-r 判断文件是否有读权限
-w 判断文件是否有写权限
-x 判断文件是否有执行权限
-e 判断文件是否存在

脚本中常用的一些语法结构:
if语句:
if test语句
then
	语句块
fi

if test语句1
then
	语句块1
else if test语句2
then 
	语句块2
else 
	语句块3
fi 
fi 
规则:有几个if就有几个then，有几个then最后就会出现几个fi

问题:
从终端输入一个文件名。判断这个文件是否存在。
如果不存在，则将输入的文件名创建为文件夹。
如果存在，提示:请输入yes删除，输入no保留。

case语句――相当于c语言的switch语句

case 变量引用 in 
	字符串1)
		语句块1
		;;   这个位置一定要加，功能其实就是break的功能
	字符串2 | 字符串3)
	//字符串3)这个位置的写法是错误的
		语句块2
		;;
	*)  相当于default
		语句块3
		;;
esac
引用的变量内容如果和下面的某个字符串匹配了则执行相应的语句块。
在脚本中break不用于跳出case语句。

$1 $2 $3 $4 $5 $6
 a  b  c  d  e f 
 执行一次shitf，则原有的$1被移走一次
		 ||
		 \/
$1 $2 $3 $4 $5
b   c  d  e  f 

while循环
while test语句  
do
	循环体
done
当test语句成立时执行循环体

例子:假设有一个文件叫做ip.txt,里面存放的内容为
192.168.1.0
192.168.1.1
192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5
192.168.1.6
...........
实现一个脚本，将ip.txt中的点分十进制ip地址转化成十进制整数然后存放到另一个文件中

提示:显示出ip.txt文件的内容，将内容存放在管道中，继续循环从管道中读每行数据，读一次就是一个点分十进制，需要进行进制转化，点分十进制可以看成是256进制的数据

0x1234 --》 十进制  
  4*16^0 + 3*16^1 + 2*16^2 + 1*16^3
