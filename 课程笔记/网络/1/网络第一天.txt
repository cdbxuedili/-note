李相山
lixs_sh@hqyj.com

网络编程:
第一天:UDP――用户数据报协议
第二天:TCP――传输控制协议
第三天:各种服务器模型
第四天：IO模型――阻塞、非阻塞、多路复用――select和epoll、异步通知
第五天:广播、组播、域套接字通信、数据库的操作方法和函数接口
第六天:自己动手写一个网络小项目


第一天:internet网   
internetwork、上世纪60年代美苏冷战，美国为了避免本土网络收到攻击出现了很多局域网，这些局域网之间不能相互通信。70年代阿帕网被分成两个部分――民用和军用，unix――system5和BSD，BSD分支下出现了网络协议栈(tcp/ip协议)，80年代初，民用的阿帕网使用了tcp/ip协议。

网络模型:OSI模型(标准化模型，没有真正使用)和tcp/ip模型(当前使用的网络模型) 

1、为什么需要网络模型？
假设A公司使用a模型，B公司使用b模型，有一天A公司收购了B公司，肯定要重新搭建网络，此时至少要推翻一家公司的模型

ISO组织规定了所有的公司搭建的网络模型标准――OSI模型。

2、OSI模型的7层结构――先有分层、再有协议
				应用层
				表示层
用户空间		    会话层   
――――――――――――――――――――――――――――――――――――――――――
内核空间		    传输层
				网络层    协议栈
――――――――――――――――――――――――――――――――――――――――――
硬件		      	链路层    网卡、交换机
				物理层


tcp/ip模型――先有协议、再有分层 
应用层 
传输层 
网络层 
网络接口和物理层
			
用户空间		应用层   http协议  telnet远程控制协议  ftp文件传输协议
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
内核空间		传输层   udp――不可靠的协议、实时性强，tcp――可靠的协议，实时性弱  
		    网络层   ip协议  icmp协议  igmp协议
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
硬件			网络接口和物理层  arp协议――地址解析协议和rarp协议――逆地址解析协议
				
				
3、PDU――协议数据单元，涉及到网络模型中对数据的封装和解封


4、数据帧的封装和解封
A,B之间要进行文件传输
			    A主机                ――――――――――――――                 B主机 

应用层       ftp头――数据         							                                                                 ftp头――数据 
				  ||												 /\
				  \/						  	        			 ||
传输层      TCP头――ftp头――数据     							                                                             TCP头――ftp头――数据
了解:tcp头或者udp头中包含源端口和目的端口号    htonl(s)  ntohl(s)                                                       判断目的端口在本机中是否使用
				  ||												  /\
				  \/												  ||
网络层      IP头――TCP头――ftp头――数据    inet_addr  inet_atoa                                               IP头――TCP头――ftp头――数据
了解:ip头中包含源ip地址和目的ip地址				                                         		       目的ip和本机ip是否一致
				  ||												  /\		
				  \/                                                                                                                                                                                            ||
       网络接口和物理层                                                                                                                                               网卡收到数据帧判断目的mac地址
	以太网头――IP头――TCP头――ftp头――数据――CRC校验码                                                                                                                         如果匹配，去掉以太网头
了解:以太网头包含源mac地址和目的mac地址		 


以太网头――IP头――TCP头――ftp头――数据――CRC校验码 叫做一帧数据

4、什么是端口号？一种操作系统中做好的一种约定。为了交给具体的进程使用
49152-65535自己可用端口号，不同的协议端口号是私有的。

PING www.a.shifen.com (115.239.210.27) 56(84) bytes of data.
		  域名          百度服务器地址	
64 bytes from 115.239.210.27: icmp_req=1 ttl=54 time=11.9 ms

64字节代表的是网络通信中，网络端口所使用的最小字节数。
icmp协议名称
icmp_req=1 第一个协议数据报
ttl=54 做大路由器个数――我这台主机所连接的路由器和百度服务器的路由器最大可以差54个
time=11.9 ms 发送数据到接收到数据的时间差值

5、路由选择问题
内网可以直接访问外网，外网不可以直接访问内网

当内核中一台主机访问外网时，首先会将数据包交给交换机，交换机提取出数据包中的mac地址和交换机的mac表比较，如果比较失败，则交换机会给当前局域网的其他主机群发，如果当前局域网其他主机不能匹配mac地址则交换机也会发送数据包给路由器，路由器获取目的ip地址，然后将数据报发送到广域网，找到最小路由选择路径，记录下路由表信息，然后数据再原路返回。

6、ip地址(ipv4和ipv6，当前使用的是ipv4)
ip地址可以唯一的描述一台主机(一台主机可以有多个ip地址，和网卡的个数有关)

ipv4是一个32位的无符号整数
ipv4分成:

基本类：A B C 
基本类包含:网络号和主机号

特殊类：D E  不区分网络号和主机号

子网掩码:一定是连续的全1和连续的全0组成
	     255.0.0.0
		 11111111 00000000 00000000 00000000
		 
		 255.255.0.0
		 11111111 11111111 00000000 00000000
		 
		 255.255.255.254
		 11111111 11111111 11111111 11111110
		 
		 
		 ip地址 & 子网掩码 = 网络号 
		 ip地址 & ~子网掩码 = 主机号
		 
A类:1字节网络号 + 3字节主机号   二进制最高位一定是0
	0xxx xxxx    xxxx xxxx xxxx xxxx xxxx xxxx
	 网络号                  主机号
	 
	网络号范围:[0,127]
    ip地址范围:0.0.0.0 - 127.255.255.255	
    
	特殊地址:0.0.0.0代表当前主机的任意ip
	         127.x.x.x 都是用来检测的，用来检测当前系统tcp/ip协议以及网卡是否安装成功。
			 ping 127.0.0.1 数据只会走到当前主机的网络层
			 
	         除了0.0.0.0和127开头的地址外，如果主机号全0代表某个网段的网络号，
			 如果主机号为全1则代表广播地址
			 
			 注意:广播地址和网络号不能给任何一台主机使用。
			 
	局域网ip:10.x.x.x
	
	理论上a类ip每个网段可以有多少台主机:2^24 - 3
	
B:	2字节网络号 + 2字节主机号   二进制最高位一定是10
	10xx xxxx xxxx xxxx     xxxx xxxx xxxx xxxx
		  网络号                    主机号 
	地址范围:128.0.0.0 - 191.255.255.255 
		
	如果主机号全0代表某个网段的网络号，
	如果主机号为全1则代表广播地址
	
	B局域网:172.16.x.x - 172.31.x.x 
	
	一个b网段可以有2^16 - 3台主机
	
C: 	3字节网络号 + 1字节主机号   二进制最高位一定是110
	110x xxxx xxxx xxxx xxxx xxxx     xxxx xxxx
	
	192.0.0.0 - 223.255.255.255 
	
	局域网地址:192.168.x.x
	
D: 	二进制最高位以1110开头
	1110 xxxx xxxx xxxx xxxx xxxx xxxx xxxx
	224.0.0.0 - 239.255.255.255
	
	专门用于组播通信
	
E:  二进制最高位以11110开头
	1111 0xxx xxxx xxxx xxxx xxxx xxxx xxxx
	240.0.0.0 - 247.255.255.255
	用于网络检测
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
内核中有一个结构体:
struct task_struct
{
	struct files_struct *p;
		   ||
		   \/
	struct file __rcu * fd_array[NR_OPEN_DEFAULT];数组下标就是文件描述符
}

socket――套接字，本质是一种文件描述符

如何产生套接字？
int socket(int domain, int type, int protocol);
参数1:通信域，如果需要网络通信只需要传递AF_INET，也可能传递PF_INET
参数2:通信协议的选择，如果使用SOCK_STREAM则使用的是TCP协议
					  如果使用SOCK_DGRAM则使用的是UDP协议
参数3:如果使用的是系统封装好的协议，则此参数传0。
返回值:套接字――文件描述符 
	
	man 7 ip查询
		struct sockaddr_in {  网络结构体
               sa_family_t    sin_family; /* address family: AF_INET */ 通信域 
               in_port_t      sin_port;   /* port in network byte order */端口号
               struct in_addr sin_addr;   /* internet address */ ip地址 
           };

           /* Internet address. */
           struct in_addr {
               uint32_t       s_addr;     /* address in network byte order */
											ip地址的网络字节序
           };

什么是字节序？主机字节序、网络字节序
主机字节序:可能是大端序，也可能是小端序。有cpu决定。			
网络字节序:一定是大端序

大端:低地址存高字节
小端:低地址存低字节

如何验证cpu的主机字节序？
int a = 0x12345678;
char *p = (char *)&a;

for(i = 0;i < 4;i ++)
	printf("%x\n",*(p + i));
如果打印顺序是:12 34 56 78	大端序
如果打印顺序是:78 56 34 12  小端序

当前cpu的主机字节序是:小端序

为了避免在不同主机中数据混乱出现了网络字节序

如何转化字节序？


struct sockaddr_in addr;

addr.sin_addr.s_addr = htonl(2 * 256^0 + 1 * 256 ^ 1 + 168 * 256 ^ 2 + 192 * 256 ^ 3);

192.168.1.2

2 * 256^0 + 1 * 256 ^ 1 + 168 * 256 ^ 2 + 192 * 256 ^ 3 主机字节序的小端序
htonl(2 * 256^0 + 1 * 256 ^ 1 + 168 * 256 ^ 2 + 192 * 256 ^ 3);


in_addr_t inet_addr(const char *);
addr.sin_addr.s_addr = inet_addr("192.168.1.2");
将一个字符串转化成整数，这个字符串必须是点分十进制的格式，最后将整数地址转化成网络字节序

char *inet_ntoa(struct in_addr in);
功能:将ip地址(网络字节序)转化成字符串格式(主机字节序)

int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
功能:绑定函数
参数1:套接字 
参数2:网络结构体首地址，传递struct sockaddr_in变量的地址，然后强转成const struct sockaddr *
参数3:struct sockaddr_in 的结构体字节数

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                  const struct sockaddr *dest_addr, socklen_t addrlen);
功能:发送数据 
参数1:套接字 
参数2:数据的存储空间首地址
参数3:数据的实际字节数
参数4:只传递0
参数5:对方的地址结构体
参数6:对方的地址结构体大小

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
功能:接收数据
参数1:套接字 
参数2:用来存放接收到的数据的空间首地址
参数3:空间大小
参数4:传递0
参数5:对方的地址结构体，真正接收到数据前是不指定对方的结构体的
参数6:

返回值:成功返回大于0的整数代表接收到的字节数
	   出错返回值为-1
	   如果有客户端断开连接则返回0
	   
总结:socket()  
	 struct sockaddr_in 
	 htons();
	 inet_addr();
	 bind()
	 sendto();
	 recvfrom();

一般情况下:主动发送的一端被叫做客户端，被动接收的一端叫做服务器
UDP发送端――客户端:
1、创建套接字
2、填充对方(服务器)的地址结构
3、填充自己的地址结构(可选的，一般不选)
4、绑定自己的地址结构(可选的) 无论哪一端，绑定一定是自己的地址结构
5、发送数据

UDP接收端――服务器:
1、创建套接字 
2、填充自己(服务器)的地址结构
3、必须绑定自己的地址结构
4、接收数据


nc  -l      172.25.1.194   50000         -u       模拟udp的接收端
   接收	    服务器地址   服务器端口    udp协议
   
nc 172.25.1.194 50000 -u 模拟发送端


作业:通过udp实现一个网络聊天室

struct 
{
	char type;如果为L则代表登陆，如果为Q代表退出，如果为T代表发言
	char name[15];//存放登陆名称
	char buf[128];
}

客户端：
搭建客户端模型
实现登陆功能――通知服务器我要登陆，设置好类型以及名字后，调用sendto发送给服务器

创建父子进程
pid = fork();

if(pid == 0) //子进程
{
	如果输入的内容不是quit，封装类型T，保存说的内容到buf中，最后调用sendto();
	如果输出的内容是quit，则封装Q，调用sendto();如果子进程退出同时要干掉父进程――给父进程发信号。
}
else //父进程
{
	while(1)
	{
		recvfrom();
		
		switch(判断类型)
		{
			case 'L':
				打印有人登陆;
				break;
			case 'T':
				打印出说的内容;
				break;
			case 'Q':
				打印出某人退出;
				break;
		}
	}
}


服务器 

struct node
{
	struct sockaddr_in data;
	struct node *next;
};

void create_empty_link()
{
	创建一个空链表
}

void user_login()
{
	//往链表中添加节点――地址结构体
	//通知其他人有人登陆了
}

void user_talk()
{
	//遍历链表
	//给除了自己之外的其他人发送数据
	//比较方法――memcmp();
}

void user_quit()
{
	//删除链表节点
	//通知其他节点某人退出了(调用sendto)
}

搭建服务器模型



while(1)
{
	recvfrom();
	
	switch(判断type)
	{
		case 'L':
			user_login();
			break;
		case 'T':
			user_talk();
			break;
		case 'Q':
			user_quit();
			break;
	}
}





