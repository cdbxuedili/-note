三次握手――建立连接

客户端  发送SYN=1      服务器
        回ACK=1 SYN=1            服务器要保证客户端收到了数据包
		发送ACK=1   
		收发数据		
		
四次挥手――断开连接

	A     发送FIN=1      B
      	  回ACK=1               A的发送和B的接收被关闭
		
    		B发送数据，A接收数据
		  ........
	      
          B给A发送FIN=1
		  A给B回ACK=1            A的接收和B的发送也被关闭
		  

一定要先执行服务器		  
tcp服务器模型
1、创建套接字
   socket(,SOCK_STREAM,);

2、填充服务器地址结构
3、绑定服务器地址结构
4、监听
   listen(套接字,允许同时连接的最大客户端个数);
5、产生新的套接字用于收发数据
	套接字 = accept(用于建立连接的套接字,客户端地址结构体,);
6、接收数据
	recv();
	
tcp客户端模型
1、创建套接字
2、填充服务器地址结构
3、请求连接 
	connect(套接字,服务器地址结构首地址,);
4、发送数据
	send();
	
tcp循环服务器――单进程，效率很低――如果有客户端未退出，则后续客户端要么等待，要么被拒绝。
为了提高服务器的使用效率，可以选择让服务器变成多任务的(多进程或者多线程)。
无论是多进程服务器还是多线程服务器，所能操作的客户端个数都是有限的。

如何使用多进程来实现tcp并发服务器。
什么叫做并发？多个客户端同时(宏观同时，微观同时)执行。

一个父进程，不知道几个子进程。
while(1)   一个父进程，无限个子进程
{
	datafd = accept(sockfd,,);
	pid = fork();
	
	if(pid == -1)
	{
	
	}
	else if(pid == 0)
	{
		colse(sockfd);
		while(1)
		{
			recv();
		}
	}
	else 
	{
		close(datafd);
//		wait(NULL);
//如果代码这么实现，子进程如果没有退出，则wait函数会阻塞，所以外层的while(1)不会执行，所以就不会产生第二个子进程。不应该在父进程中添加wait函数。
	}
}


signal(SIGCHLD,SIG_IGN);//init进程回收子进程资源
while(1)   一个父进程，无限个子进程
{
	datafd = accept(sockfd,,);
	pid = fork();
	
	if(pid == -1)
	{
	
	}
	else if(pid == 0)
	{
		colse(sockfd);
		while(1)
		{
			recv();
		}
	}
	else 
	{
		close(datafd);
	}
}


pid1 = fork();

if(pid1 == -1)
{}

if(pid1 == 0)
{
	accept();
	pid2 = fork();
	
	if(pid2 == -1)
	{
	
	}
	if(pid2 == 0) //孙进程
	{
		while(1)
		{
			recv();
		}
	}
	else 子进程 
	{
		exit(0);
	}
}
else //父进程
{
	wait(NULL);
}

基于tcp并发服务器，来实现文件的下载功能，查询服务器中的文件名。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
网络中的IO模型:
阻塞――过程中会释放cpu
可执行文件存放在硬盘――准备执行前会将其加载到内存中(代码段――存放了cpu识别的指令、数据段、堆栈等等)―― 指令被加载到cpu中(当前任务正在占用cpu)
一旦一个进程阻塞，则进程信息会被踢出cpu(当前进程不再占用cpu)，一旦cpu被释放其他任务可以拥有cpu。

一个进程被踢出cpu后，内核中有一个专门的空间(双向循环链表――等待队列)存放进程信息。

阻塞分成:读阻塞、写阻塞(几乎使用不到，一般当空间不足时会出现写阻塞)

什么叫做读？数据从设备流向内核空间，再从内核空间流向用户空间
什么时候可能出现读阻塞？1、压根没有数据   2、有数据但是内核未向上提交

作为应用程序，调用的读/接收相关函数，默认都可以阻塞。

如果代码的某个位置出现阻塞，阻塞下面的功能不能执行。但是如果阻塞下面的功能很重要，则我们需要将阻塞的函数变成非阻塞函数，或者多路复用，或者是异步通知。

非阻塞:在非阻塞过程中，不会释放cpu，而且还变本加厉大量占用cpu――精神病
如何使用非阻塞？
int fcntl(int fd, int cmd, ... /* arg */ );
参数1:文件描述符
参数2:可以传递F_GETFL，获取文件描述符的属性,会交给fcntl的返回值
	  可以传递F_SETFL，设置文件描述符属性，此时需要参数3
参数3:如果传递的是F_GETFL，则省略
	  如果传递的是F_SETFL，则需要传递文件描述符属性

fd = open("",O_RDONLY);
flag = fcntl(fd,F_GETFL); //flag 存放了O_RDONLY

异步通知――信号操作，SIGIO
信号如何产生、如何注册、如何消亡和执行

man 2 open 
找O_ASYNC，当文件描述符中包含了这个属性，默认进程会操作SIGIO

signal(SIGIO,函数名);
flag = fcntl(fd,F_GETFL);
flag |= O_ASYNC;//使进程具备异步特性
fcntl(fd,F_SETFL,flag);//让文件描述符具备异步属性
fcntl(fd,F_SETOWN,进程号);//给指定的进程注册信号(这里不是注册信号，内核源码自动注册)

什么是异步？对中断方式的一种软件模拟
signal(信号值,函数名);
				||
			  信号处理函数
多路复用








