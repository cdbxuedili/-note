网络模型:
OSI模型:
应用层
表示层
会话层
――――――――――――――――――――――――――――――
传输层
网络层
――――――――――――――――――――――――――――――
链路层
物理层


TCP/IP模型:
应用层
――――――――――――――――――――――――――――――――
传输层
网络层 
――――――――――――――――――――――――――――――――
网络接口和物理层


数据帧的封装和解封
以太网头(源mac地址和目的mac地址)+ip头(源ip和目的ip)+udp头(源端口和目的端口)+协议头+数据+
crc校验码


端口:本质就是一个无符号的整数 最好使用的范围49152-65535
习惯怎么做――要求怎样做

路由器:一端接外网、一端接内网

ip地址:
无符号的32位整数
A B C
三类会有网络号和主机号之分，主机号全0代表网络号，主机号全1代表广播地址，每个网段中都会有三个地址是不能分配给主机的，网络号、广播地址、网关

A
以0开头
255.0.0.0
0.0.0.0 - 127.255.255.255

10.x.x.x
每个网段可以有多少台主机？2^24 - 3

B
以10开头
255.255.0.0
128.0.0.0 - 191.255.255.255

172.16.x.x - 172.31.x.x

每个网段有多少台主机:2^16 - 3

C
以110开头
255.255.255.0
192.0.0.0 - 223.255.255.255

192.168.x.x 

D E没有网络号和主机号

D
以1110开头
224.0.0.0 - 239.255.255.255
专门用于组播通信

E
240.0.0.0 - 247.255.255.255

ip & 子网掩码 = 网络号
ip & ~子网掩码 = 主机号

套接字 = socket(AF_INET,SOCK_DGRAM,0);

struct sockaddr_in 
{
	通信域   AF_INET 
	端口   16位的，网络字节序
	ip地址  整数，网络字节序
}


主机字节序转化为网络字节序
htons();
htonl();

网络字节序转化为主机字节序
ntohs();
ntohl();

网络字节序ip地址的整数 = inet_addr("字符串――代表点分十进制格式的ip地址");

bind(套接字,const struct sockaddr *,结构体大小); 只能绑定自己的地址结构

sendto(套接字,缓存区首地址,数据实际字节数,0,对方的地址结构体首地址,对方地址结构体大小);
recvfrom(套接字,缓存区首地址,缓存区的大小,0,对方的地址结构体首地址,&对方地址结构体大小);

udp客户端模型――发送端:
1、创建套接字
	socket();
2、填充对方的地址结构体(服务器的)
3、发送数据
	sendto();

udp服务器模型――接收端:
1、创建套接字 
2、填充自己的地址结构体
3、绑定
4、接收数据
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
tcp协议:可靠的，有连接的
特性:由三次握手来实现

1）	主机A    ――――――――――――――――――――》   主机B
			 数据包SYN=1              如果B收到SYN置1的数据包，则B认为A在请求建立连接

2）	主机A    《――――――――――――――――――     主机B
			 回数据包ACK=1 SYN=1
	如果A收到ACK=1说明B之前
	收到了连接请求
    如果同时收到SYN=1，说明B也要
	确认A是否收到了ACK=1
	
3、	主机A   ―――――――――――――――――――――――》  主机B
		    回ACK=1                   如果B收到了ACK=1，说明后续可以正常数据通信了
			
	主机A   ――――――――――――――――――》	主机B
			发送数据 
	主机A   《――――――――――――――――――――  主机B
			  接收数据
模拟的一个三次握手
A问:在么？
B回答:我在，有什么事
A回到:嗯，没事，我知道你在
说正事了。


如果两端通信完成后需要断开链接，TCP使用四次挥手来断开连接
1）	主机A     ―――――――――――――――――――》  主机B
			  发送数据包FIN=1        B收到FIN=1，说明A要断开连接
2）	主机A    《――――――――――――――――――    主机B
			  回数据包ACK=1
	主机A收到B的数据包后，说明主机A此时可以不需要再发送数据了，同时主机B停止接收数据

	主机A     《――――――――――――――――――   主机B 
				B给A发送数据
				............
				
3）	主机A     《――――――――――――――――――    主机B
				给A发送FIN=1
4）	主机A      ―――――――――――――――――――》  主机B
    此时A不再收数据，B不再发送数据	
	
tcp使用时一定要先执行接收端

tcp服务器端模型:
一个文件描述符专门用来建立连接，另一个文件描述符专门收发数据。
连接建立成功后会产生一个新的文件描述符，用来收发数据。
1、创建套接字 
	套接字 = socket(AF_INET,SOCK_STREAM,0);
	这个套接字用来建立连接的。
2、填充服务器的地址结构体
	和udp服务端无任何区别
3、绑定服务器地址结构
	和udp服务端无任何区别
4、监听――为了和客户端建立连接做准备
	int listen(int sockfd, int backlog);
	参数1:用于建立连接的套接字
	参数2:服务端可以同时拥有的客户端最大请求数，超出的客户端会被拒绝
	注意:监听不会阻塞
5、产生新的文件描述符
	int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	会阻塞
	参数1:用于连接的套接字
	参数2:接收的是客户端的地址结构
	参数3:客户端地址结构体大小
	返回值:文件描述符，用于收发数据
	以上如果都正常执行成功，说明三次握手建立成功
6、接收数据――使用的是新的文件描述符
	ssize_t recv(int sockfd, void *buf, size_t len, int flags);
	四个参数的用法和recvfrom的前四个参数完全一致
	返回值:>0 正确接收的数据字节数
	       =0 有客户端退出
		   <0 出错
		   

tcp的客户端模型:
1、创建套接字 
	套接字 = socket(AF_INET,SOCK_STREAM,0);
	这个套接字既可以用于请求连接，又可以用来收发数据
2、填充服务器的地址结构
	同udp的客户端
/*
3、填充自己的地址结构
4、绑定自己的地址结构  
这两步一般不用
*/
5、请求建立连接
   int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
   参数1:套接字
   参数2:服务器的地址结构
   参数3:服务器地址结构体大小
6、发送数据
	ssize_t send(int sockfd, const void *buf, size_t len, int flags);
	和sendto函数的前四个参数完全一致

	
作业:tcp客户端负责读取出1.txt文件的内容，将内容发送给服务器，服务器接收数据后将数据存放到2.txt 	
	
