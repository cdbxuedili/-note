  
创建工程:file->new->project->console application ...
打开工程:file->open->找到某个具体目录下的xxx.cbp

切换使用的工程:直接在工程名称上双击鼠标

在工程中添加空文件:file->new->empty file->自己指定文件名和后缀->...

如何编译文件:ctrl + f9 
如何编译并且运行文件:f9

一、C++是C语言的超集(c有的功能，c++全有，c++有的功能，c不一定有)
C语言是一种面向过程的语言。
C++语言:
	面向过程――只要学过c语言就没有什么问题
		数据类型、常量、变量、运算符、表达式、输入输出、控制语句(分支语句和循环语句)
		数组、指针、函数、结构体、动态申请空间以及释放空间
	面向对象――C++的重中之重
		封装、继承、多态
	泛型编程――函数模板和类模板，智能指针

二、数据类型
1、什么是数据类型？
本身不占空间，为了告诉编译器这种类型定义的变量需要占用多大空间。

2、数据类型分类
基本类型:char short int long long long c++同c
		 bool其实在c语言中并不存在，gnu c对其进行了扩展。
		 
		 bool a = 10;代表的是变量a为真
		 bool a = true;
		 
		 bool b = 0;代表变量b为假
		 bool b = false;
		 这种类型用来判断表达式是否成立
	
		bool类型在c++中有个特殊用法:bool类型可以自增，不可以自减

构造类型:数组、结构体、共用体
		 
		 c++中还可以认为类是一种构造类型(类是基于结构体的一种升级)
		 c++中一般结构体能实现的功能都用类代替了。
指针类型:一级指针、二级指针、数组指针、函数指针、结构体指针  c++和c这部分没有区别
空类型:void

3、头文件问题
早期的c和c++只支持xxx.h后缀的头文件
现在的c同样只支持xxx.h后缀
现在的c++既支持.h后缀，又支持去掉.h后缀的方式
以xxx.h和xxx为例

当前c++中: #include <xxx.h> 或者 #include <xxx>
一定要注意:xxx.h头文件就是从c中拿过来的文件，而xxx这种文件是c++重写的(本质是一个类)	

如果c++引用了c中的头文件，可以有两种包含方式:
第一种:#include <stdio.h>
第二种:#include <cstdio>	

iostream类继承了istream类和ostream类

三、常量――在程序运行期间不能修改的数据
整型常量:10  0xa  0664   同c
字符常量:'字符' 同样也可以查ascii表  同c
字符串常量:"hello"以字符'\0'结尾
			c语言中可以用什么方式来存放字符串？
			char s[] = "hello";//栈空间，hello可以被修改
			
			char *s = "hello";//静态区，hello不能被修改
			
			c++提供了一个新的机制:string类型
			string s = "hello";//string本质是一个类，定义出来的变叫做对象
浮点常量:float a = 1.123  同c
指数常量:1.1e3  同c
标识常量(宏):#define N 10 c++同样可以这样做，但是c++不建议这样使用
			 c++使用了两种方法来替代宏(内联函数、const)
	
	const int a = 10;
    int *p = (int *)&a;

    *p = 100;
    printf("a = %d\n",a);//如果是c代码打印结果是100，通过指针间接修改了只读空间内容
						 //如果是c++代码打印结果是10，指针不能修改只读空间内容
	c++对c中的const做了优化，它认为c中的const不严谨。					 
	
	c和c++的编译过程一样:
	预处理、编译、汇编、链接
	宏替换在预处理阶段，不检查语法错误
	const变量在编译阶段，检查语法错误
	
四、变量:
c++中的变量最终也需要存放到内存中。
内存分区:代码区(.text段)、数据区(.data段，.bss段，.rodata段)、栈区(一定是连续的)、堆区
		 
	定义方法:存储类型 数据类型 变量名;

存储类型:
		auto:只能修饰局部动态变量，如果没有初始化默认值为随机值，默认auto可以省略
		register:只能修饰局部动态变量，使用的是寄存器空间，为了提高效率。
				 c语言中的register变量不能取地址
		static:
			1、修饰的全局变量，不能被其他文件引用
			2、重复调用时只能初始化1次(保留上一次的结果)
			3、在类中还有其他用法
			
		extern:主要作用就是引用其他文件中的函数或者是全局变量
		
五、运算符
算数运算符
关系运算符
逻辑运算符
位运算符  
sizeof运算符 以上同c
赋值运算符
	int a = 10;<==> int a(10)定义的同时初始化;
	
	int x = 100;//在c++中这句话叫做初始化
	或者 
	int x;
	x = 100;//这句话叫做赋值
	
	涉及到复合类型或者指针类型时，初始化和赋值是不同的两个概念。
	只不过对于普通类型来说初始化和赋值不做区分。
	
逗号运算符:同c 是所有运算符中优先级最低的
			int a = (1,2,3,4,5);a的结果是5 
三目运算符:条件运算符
			表达式1 ? 表达式2 : 表达式3
			如果表达式1成立，则整个表达式结果为表达式2，否则为表达式3
			c++中的条件运算符可以作为左值。

六、c++中的强转问题
c语言的强转:隐式强转(编译器做)和显示强转(自己做)
			显示强转的规则:
			type a = (type)b;
			
			int a = 10;
			double b = 1.123;
			b = (double)a;
			
			int *p;
			char *q;
			q = (char *)p;
			
c++的强转规则兼容了c的强转规则(也可以像c语言一样使用显示强转)，同时还做了扩展。
int *p;
char *q;
q = (char *)p;

强转的扩展:新增了四个函数来进行强转
比如:对于普通类型，指针类型，对象，继承等机制使用的强转函数不同。
static_cast <类型> (变量名);
reinterpret_cast<>();
const_cast<>();
dynamic_cast<>();


七、输入输出――这里的东西会用就行了，千万别去研究里面的各种控制符号。
c语言中:scanf printf 
		getchar putchar
		gets puts
c++中:
cin:标准输入,有缓存
cout:标准输出,有缓存
cerr:标准错误输出,没有缓存

和终端相关的如何刷新缓存？\n
c++中和终端相关的缓存如何刷新？endl相当于\n

八、c++独有的命名空间问题
c语言的一个工程，有一个全局。

比如:

int a;//c++可以有特殊的写法――命名空间
void fun()
{
	a = 10;//如果是c语言肯定可以直接使用，但如果是c++不确定了。
}

main()
{
	
}

为什么会有命名空间？
c工程中，可以使用动态库(标准动态库，第三方动态库)，假设A厂家开发了动态库a，B厂家开发了动态库b，此时我们在写工程时同时调用了动态库a和b，可能出现a中和b中会有相同的函数名或者变量名。使用过程中出现了冲突。为了避免冲突c++提供了名称空间(每个名称空间就是一个独立的全局)。

标准名称空间内容有很多――上千行的代码。
cout和endl在std名称空间中。要想使用cout和endl必须要先使用std。

std的使用方法:
1、using namespace std;//std中包含的所有内容都可以执行使用
2、std :: cout << "hello" << std::endl;//只有当前语句可以使用cout和endl，其他语句不能使用
3、using std::cout;//在当前代码块中后续的代码就可以直接使用cout了。
::作用域限定符

如何自定义一个名称空间？
有名名称空间――显示调用
			1、using namespace std;
			2、std :: cout << "hello" << std::endl;
			3、using std::cout;
无名名称空间――默认被调用，不建议使用无名的

九、控制语句
逻辑和c都是一样的

c语言:
int i;
for(i = 0;i < 5;i ++)
{

}

c++还可以这样写:
for(int i = 0;i < 5;i ++)
for(int i(0);i < 5;i ++)
{
	
}
i = 10;//在循环的外部使用变量i，可以么？不可以使用，这种用法中，变量i的作用域只是for内部

十、数组――一段连续的空间，用来存放相同类型的数据。
一维数组:
1、数组的定义方法
	存储类型 数据类型 数组名[数组大小];
2、数组的初始化方法
	全部初始化
		int a[5] = {1,2,3,4,5};
		int a[] = {1,2,3,4,5};
	部分初始化
		int a[5] = {1,2,3};
3、数组元素可以使用下标法来描述
	int a[5] = {a[0],a[1],a[2],a[3],a[4]};
	下标法是变量   a[0] ++允许的

4、数组名――代表了整个数组空间，地址常量


二维数组:
1、定义方法
	存储类型 数据类型 数组名[行数][列数];
	
2、初始化
	全部初始化
		int a[2][3] = {1,2,3,4,5,6};
		int a[][3] = {1,2,3,4,5,6};
		
		int a[2][3] = {{1,2,3},{4,5,6}};
		int a[][3] = {{1,2,3},{4,5,6}};
	部分初始化
		int a[2][3] = {1,2,3,4};
		int a[][3] = {1,2,3,4};//允许
		1 2 3
		4 0 0
3、下标
	int a[2][3] = {
		{a[0][0],a[0][1],a[0][2]},
		{a[1][0],a[1][1],a[1][2]}
	}
		
4、二维数组的数组名――行地址
以上内容c++都具备。

十一、指针
内存编号，也叫做地址编号，还叫做指针常量。
用来存放指针常量的变量，叫做指针变量。
在c语言或者c++中习惯将指针变量以及指针常量统称为指针。

一级指针和一维数组的关系
int a[5];
int *p = a;
*(a + i) <==> a[i]
	||
*(p + i) <== > p[i]

数组指针和二维数组的关系
int a[2][3];
理解过程:int a[2][3]==>int (a[2])[3]; ==》 int (*)[3];
					   为什么将a[2]括起来  数组指针类型
					   因为行序优先		

变量的基本定义语法:数据类型 变量名;					   
int (*)[3] p;//但是现在所有的编译器版本都不支持(曾经支持)
int (*p)[3];//当前编译器支持的格式。
p = a;

行指针:
0 <= i < 2
p + i
&p[i] <==> & *(p + i)
		  &和*互为逆运算

列指针:
0 <= i < 2
0 <= j < 3
*(p + i) + j
p[i] + j

二级指针和指针数组的关系
char *str[] = {"hello","world","farsight"};
str是一维数组名，这个数组存放了三个字符串的首地址

思考:char *str[] = char *(str[]); ==> char *(*); ==>char **;
char **p = str;
以上都是c语言内容，c++同样完全支持。

十二、引用
对于很多人来说，指针读起来或者学起来比较麻烦。c++除了指针之外还提供了引用。
c语言中有指针。
java里有引用。
c++中有指针和引用。

1、什么是引用？就是一个变量的别名(引用就是一个变量本身，名字改了)
	非const引用(普通引用)
	const引用
2、普通引用的使用方法
	数据类型& 别名 = 变量名;
	int a = 10;
	int *p = &a;
	cout << *p << endl;
	
	int a = 10;
	int& b = a;//b是a的别名
	
3、普通引用的注意事项
a、定义时必须初始化
b、不能给常量取别名
c、不能用于表达式
d、不同的类型之间不能取别名(强转后也不行)
非const引用之间的地址一定是相同的

4、const应用的特性
a、定义时必须初始化
b、可以给常量取别名
c、可以用于表达式
d、不同类型之间可以取别名
const引用相互之间地址可能不同。

5、引用的目的是什么？给函数传参

6、引用的本质？就是地址的使用
void fun(int& b)//b是a的别名
{
	
}

main()
{
	int a = 10;
	fun(a);
}
以上用法是我们在c++工具中自己写的。
	||
	\/
执行之前，必须要通过编译器编译。编译器在编译前会将以上代表进行转化(看不到)。
void fun(int* const b)
{
	
}

main()
{
	int a = 10;
	fun(&a);
}
使用引用本质使用的是地址。
所有的引用在内存中都占用4个字节。

7、什么时候使用引用？
	a、基本变量的操作，一般就是直接赋值
	b、数组的操作，一般用指针
	c、结构体的操作，可以选择指针，也可以选择引用
	d、类的对象，一般使用引用。
	
十三、如何使用引用来传参
c语言中的传参方式:
	按值传递
	按地址传递
	
c++中传参方式:
	按值传递
	按地址传递
	按引用传递
	
返回值为引用？很重要，因为在加法运算符重载中会使用到(连续+)。

十四、函数的默认参――通常会出现在构造函数中
默认参数的设置必须从由向左。如果我们右边的所有参数都设置为默认的，则调用时可以给所有参数传参，也可以只给没有设置的参数传参。	

十五、函数的占位参――用在运算符重载
占位参在运算符重载时会使用到，这个位置的参数并不是为了传递具体值，只是为了区分不同情况的
如果只使用了占位参，调用函数时必须给占位参传参(虽然没有使用)
如果占位参和默认参结合使用，调用时可以省略占位参对应的实参。

十六、函数的重载(函数的多态)
1、什么是重载？赋予函数新的意义。

<<逻辑左移运算符
cout << "hello" 用于输出的一个运算符
以上两个运算符就是重载

2、函数重载的特点
a、函数名相同
b、函数参数的个数不同、函数的参数类型不同、参数的个数和参数的类型都不同。
c、函数的返回值不是重载的判断条件

如果有函数的重载，编译器会根据参数的个数以及类型来决定调用哪个何时的函数接口。

3、任何时候都可以使用函数重载么？
a、当默认参和函数重载同时出现时，可能出现二义性(报错)。	
b、函数重载遇见引用作为参数时，可能出现二义性(报错)。
c、是否可以通过函数指针来实现函数的重载？不可以

十七、内联函数
void add(int a,int b)//正常函数
{
	return a + b;
}

inline void add(int a,int b)//内联函数
{
	return a + b;
}

内联函数通常出现在头文件中，内联函数就是用来代替c中的复杂宏。
正常函数，如果被调用10次，在内存中只需要占用1分函数的空间(入栈和出栈)
内联函数，如果被调用10次，在内存中就会占用10份内存(一堆字符串的替换)
内联函数效率高，但是不建议多次调用(会大量占用内存)。

十八、如何动态申请空间
c语言中使用malloc和free，c++也可以这样用。但是几乎不这样使用。
c++中提供了4个关键字用来申请和释放空间。

new 
delete

new[]
delete[]



