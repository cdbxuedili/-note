友元函数:一定是全局函数，全局函数不一定是有元函数
当一个全局函数需要使用类中的某些私有属性时

class test
{
private:
	int a;
	friend void fun();//安丽满――都是朋友
};

void fun()
{
	使用私有属性a;
}

运算符重载:赋予一个运算符新的含义，没有改变运算符的原有含义。
	根据c++提供的规则封装的函数。c++编译器会根据运算符左右的操作数类型来选择使用哪个函数。

int a = 10;
int b = 20;

a * b;===>c++编译器会调用内部封装的一个函数接口 operator*()

test a(10);
test b(20)
a * b;默认c++编译器不认识，所以要想操作必须要重载*运算符(自己封装一个函数operator*()) 
以上同种接口调用不同源码的这种情况，可以叫做函数的多态。

重载的语法规则:
c++运算符分为:单目运算符
			  双目运算符
			  三目运算符 ?:  c++说了它不能重载
			  
双目运算符:opd1 opt opd2
	友元函数重载
		返回值类型 operator opt(opd1,opd2);
	成员函数重载
	返回值类型 opd1.operator opet(opd2);//定义的时候需要将operator这个函数拿到类中定义
	正在定义时，opd1会被替换成this指针
	
单目运算符:opd opt 或者 opt opd
	友元函数重载
		返回值类型 operator opt(opd);
	成员函数重载
		返回值类型 opd.operator opt();
		
只能使用全局函数重载:<< >> 
只能使用成员函数重载: = [] () ->
两种都可以的:尽量使用成员函数法	

继承:你从父母那里继承了各种基因。
	 子进程会继承父进程的大部分资源。
	 
	 你有的我也可以使用。使用继承的目录是为了引用别人写过的，编译过的好用的代码。

组合:天天都在用

class A
{
private:
	int a;
};

class B
{
private:
	int a;
	A obj1;//组合，不是继承
	A obj2;
};

c++中无论是组合还是继承都可以复用代码。
组合:找了一个老大爷来家里打扫卫生。
继承:叫了我的爸爸来家里打扫卫生。
	 父类中有的东西，子类中一定也有。
	 
继承的语法结构:
class parent
{

};

class child:访问控制权限 parent
{

};

访问控制权限:public private protected
继承方式:公有继承、私有继承、受保护继承
		 最常用的是公有继承
		 
继承后的子类会拥有父类中的所有属性和方法。

公有继承:
	父类中:public protected private
	继承后对应的属性权限会发生改变
	子类中:public protected private

受保护继承:	
class parent
{
};

class child:protected parent 
{
};

父类中:public 		protected 	private
继承后:protected    protected 	private

私有继承:
class parent
{
};

class child:private parent 
{
};
父类中:public 		protected 	private
继承后:private		private 	private


public:类的内部和类的外部都可以调用属性
private:当前类的内部可以调用，类的外部不可以调用，继承后的子类也不可以调用
protected:当前类的内部可以调用，类的外部不可以调用，继承后的子类可以调用。
如果没有继承，private和protected没区别。如果有继承，父类中私有属性不能被子类使用，父类中受保护的属性可以被子类使用。


在继承中:先执行父类的构造函数，再执行子类的构造函数。
		 析构的顺序和构造的顺序相反
		 
在继承和组合中:
构造函数的调用顺序:先掉父类构造，再调用组合的构造，最后调用子类的构造
		  析构顺序:和构造顺序相反。
		  
在继承中父类和子类中会出现同名变量:
1、子类中的同名变量可能会覆盖父类中同名变量
2、继承后父类中的同名变量和子类中的同名变量都存在		


假设父类中有一个静态变量，子类继承父类。静态变量是备份还是共享？

多继承:只需要了解，不要重点看它，项目开发中，多继承其实是被摒弃的。
class A1
{
private:
	int a;
};

class A2
{
protected:
	int b;
};

class B:public A1,public A2
{

};
//说明B继承了A1和A2――多继承

多态:一个接口，多种状态（一个函数多种调用）
继承是为了复用前人写的代码，多态是为了复用前人或者后人写的接口。

学习多态有几个前题:
1、类型兼容性原则(赋值兼容性原则)
	a、在继承中子类可以直接当做父类使用。
	b、子类可以直接给父类初始化。
	c、子类可以直接给父类赋值。
	d、父类指针可以指向子类对象。
	e、父类引用可以给子类对象取别名。
	
2、父类和子类中出现了同名方法？
	函数的重载:
	a、函数名一致
	b、参数的个数或者参数的类型不一致
	c、返回值不作为重载的判断条件
	d、只限于当前类中，子类继承的父类的函数在子类中不会重载
	e、属于静态链编――早绑定
	
	函数的重写:
	a、一定有继承
	b、父类中的方法和子类中的方法完全一致时会发生重写
		虚函数重写――会发生方法的覆盖
		非虚函数重写――会发生方法的隐藏
	c、动态链编――晚绑定

	
	if 父类函数名和子类函数名一致，但是参数不一致
		发生方法的隐藏
	else if 父类的函数原型和子类中的函数原型完全一致，但是没有virtual
		发生方法的隐藏
	else 父类的函数原型和子类中的函数原型完全一致，有virtual
		发生方法的覆盖
	
	什么是方法的隐藏？从父类中继承过来了，子类不能用。(函数还在)
	什么是方法的覆盖？从父类中继承过来了，但是继承过来后被替换掉了。(函数不在了)
	
3、多态的产生条件
	a、有继承
	b、有虚函数(有虚函数才有覆盖)
	c、有类型兼容性原则(父类指针指向子类对象、父类引用给子类对象取别名)
	
4、为什么加virtual就可以产生多态？
	c++在编译时如果在类中看到了virtual关键字，则就会在类里面主动新增一个成员，这个成员
是一个指针，这个指针叫做vptr(虚指针)，这个虚指针产生的同时会指向虚函数表，在虚函数表中
存放了各种虚函数的入口地址。

问题1？如何验证虚指针的存在	
问题2？析构函数可以是虚的么？ 可以
问题3？父类的构造函数中调用虚函数时不能实现多态				
	已经指向了子类对象，如果有多态则只会调用子类的print函数
    实际情况是先调用了父类的print函数，最后调用了子类print函数
                 
5、纯虚函数和抽象类
a、什么是纯虚函数？
	在基类中声明，在派生类中定义。
	
	例如:我是你们的项目经理，我只知道项目需求，做项目前我自己要先做好接口的封装，如果这些接口有多态需求，则最好使用纯虚函数。
	
	语法格式:
	class 类名    现在就是一个抽象类
	{
	public:
		virtual 返回值类型 虚函数名(参数列表) = 0;
	};
	
b、什么是抽象类？
	一个类中如果包含了纯虚函数，就叫做抽象类。
	一个子类继承了父类，父类中有纯虚函数，但是子类没有定义这个纯虚函数，那么此时的子类也是抽象类。
	
	抽象类千万不能作为函数的返回值类型，也不能作为函数的参数类型,也不能直接使用抽象类定义对象。
	
	可以通过抽象类定义指针和引用
	
	A a;//错误
	A *p;//正确
	
	fun(A a)//错误
	{
	
	}
	
	fun(A *p)//正确
	{
	
	}
	
	A fun() //错误的
	{
		
	}
	
c++中强转函数
static_cast<>()  
可以用于普通类型之间的强转，不能用于指针的转换，c语言中所有的隐式强转都可以用这个函数来代替。可以用于继承间的强转。

reinterpret_cast<>() //可以用于指针之间的强转
					 //将一个整数转换成指针
					 //将一个指针转换成整数
					 总结:只要是和指针相关的强转都可以用这个函数(c语言中所有的显示强转)
						  无论有没有继承都可以强制转换
const_cast<>()  //专门用来去除const属性
dynamic_cast<>()
