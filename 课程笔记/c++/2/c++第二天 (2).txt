c++:是c的超集
面向过程
面向对象
泛型编程

数据类型:bool类型代表了真或者假
		 非0为真，0为假
		 true为真，false为假
		 可以自增，不能自减
		 
常量:
标志常量(宏):#define N 10 预处理过程来替换，不检查语法错误
			 建议使用const int a = 10; 编译过程，检查语法错误，并且还提供了类型
			 c里面的const是假的，c++的const是真的。
			 const int a = 10;
			 int *p = (int *)&a;
			 *p = 100;
			 printf("a = %d\n",a);
			 如果是c代码打印结果为100
			 c++代码打印结果为10
			 
变量:在内存中的分配和c是一样的。	
	 代码段、数据段、栈区、堆区	
	 存储类型 数据类型 变量名;
	 auto
	 register:c不能对这种类型变量取地址，c++可以
	 extern
	 static:修饰的全局变量不能被其他文件引用
			修饰的变量只能初始化1次
			专门修饰类中的成员
			
运算符:
三目运算符
	int a = 10;
	int b = 20;
	int c;
	c = a > b ? a : b;
	
	a > b ? a : b = 100;//本质给b赋值
	a > b ? 10 : 20 = 100;//错误的

强转:
c中的强转――隐式强转(编译器做)和显示强转(自己做)
		显示强转：type a = (type)b;
c++的强转兼容了c的强转。
同时c++还有特殊用法:type a = (type)b;
					type a = type (b);
					type a = static_cast<type> (b);
					
输入和输出:
输入:
int a;
cin >> a;//从终端输入内容给变量a

输出:
cout << "hello" << endl;//将字符串hello打印到终端
						//endl就是\n有刷新缓存区的作用
						
int a = 100；
cout << a << endl;
cout << &a << endl;//打印地址

char b = 'w';
cout << b << endl;
cout << (int)b << endl;//打印字符对应的ascii码

char *p = "world";
char p[] = "world";
cout << p <<endl;//打印字符串

cout << showbase << hex << a << endl;//输出十六进制
					oct   
					dec
cout << a << endl;

c++使用的头文件:xxx.h
				建议xxx，如果xxx.h是c语言的头文件，则使用cxxx
				如果没有.h后缀本质是一个类。

名称空间:避免同名接口对工程造成影响。
语法格式:
namespace   无名的名称空间
{
	int a;
	
	void fun()
	{
		
	}
}
源码只要包含了对应头文件默认使用无名名称空间。不建议使用。

namespace xxx 
{
	int a;
	char b;
}

源码中如果想使用xxx中的内容，默认不能使用。
xxx::a 源码中每当使用a时都必须要写xxx::a
using xxx::a 源码中只需要写一次，后续的a就可以直接使用了，但是其他的内容不可以使用 
using namespace xxx 只需要调用一次，这个名称空间中的所有内容都可以直接使用

int i;
for(i = 0;i < 5;i ++) c的写法
{

}

for(int i = 0;i < 5;i ++) c++的写法，变量i只能用于for循环内部
{
	
}

c++中提供了指针和引用
引用:
int b = 10;
int& a = b;
b就是一个普通变量，a是一个引用名称。a是b的别名(a就是b)

注意:引用定义的同时必须要初始化
	 不可以给常量取别名
	 不能给表达式取别名
	 不能操作不同的数据类型 
普通引用和原有变量的地址是相同的
	 
const引用:
int b = 10;
double c = 20;
const int& a = b;

注意:引用定义的同时必须要初始化
	 可以给常量取别名  const int& a = 100;
	 能给表达式取别名  const int& a = b + 1;
	 能操作不同的数据类型 const int& a = c;
const引用和原有变量的地址可能是不同的	 

引用本质是:就是地址
void fun(int& x)
{

}

//int& x = a;
main()
{
	int a = 10;
	fun(a);
}
	||
	\/
编译器内部:
void fun(int *x)
{

}

main()
{
	int a = 10;
	fun(&a);
}

可以使用引用来传参
c++传参方式:
1、值传递
2、地址传递
3、引用传递

void swap(int& a,int& b)
{
	
}

main()
{
	int a = 10;
	int b = 20;
	
	swap(a,b);
	swap(1,2);//使用时形参要加const
}

引用作为函数返回值：
int fun()
{
	int a = 10;
	return a;
}

int& fun()
{
	int a = 10;
	return a;
}

main()
{
	int ret1;
	ret1 = fun();//将a的值做了备份给了ret1，a被释放
	cout << ret1 << endl;
	cout << ret1 << endl;
	
	const int& ret2 = fun();//ret2是a的别名，几乎不会使用
	
	int ret3;
	ret3 = fun();//将a做了备份给ret3，再释放a
	cout << ret3 << endl;//10
	cout << ret3 << endl;//10
	
	int& ret4 = fun();//将a的本身给了ret4，函数执行完后a会释放，所以ret4也会释放。
	cout << ret4 << endl;//10
	cout << ret4 << endl;//随机值
}

c++的函数特殊性:
默认参数
	void fun(int a,int b,int c = 10)
	{
	
	}
	
	fun(1,2,3);//c使用3
	fun(1,2);//c使用10
	
	只有中间的参数作为默认参，不可以。必须从由向左来设置
	
占位参数
	void fun(int a,int b,int)
	{
		
	}
	
	fun(1,2);//错误的
	fun(1,2,3)//正确的
	使用占位参时，占位的参数虽然没有直接使用，但是必须要传递实参。
	
	void fun(int a,int b,int=0)//默认参和占位参结合
	{
		
	}
	fun(1,2);//正确的

函数的重载――赋予函数新的含义
条件:
1、函数名必须相同
2、参数个数、参数类型、参数类型以及个数都不相同
3、返回值类型不作为重载的标准

void fun(int a,int b)
{
	
}

void fun(int a,int b,int c)
{
	
}

main()
{
	fun(1,2);
	fun(1,2,3);
	编译器会自动识别具体要调用哪个函数
}

重载遇见默认参数:
void fun(int a,int b)
{
	
}

void fun(int a,int b,int c=0)
{
	
}

main()
{
	fun(1,2);//编译器发现上面两个函数都可以使用(到底该用谁，编译器分不清了，报错)
}
――――――――――――――――――――――
void fun(int a,int b)
{
	
}

void fun(int& a,int& b)
{
	
}

main()
{
	int a = 10;
	int b = 20;
	fun(a,b);//编译器发现上面两个函数都可以使用(到底该用谁，编译器分不清了，报错)
}

动态申请空间:
malloc()和free()

new
delete

new []
delete []
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
结构体
c语言中的结构体:
struct 标签名称
{
	int a;//成员
	char b;
};
struct 标签名称 变量名;
标签名称 变量名;//可以么？
	1、c语言中不可以直接使用标签来定义变量，c++可以

	2、c语言的结构体中可以有函数源码么？不可以，c++可以

	3、c语言的结构体是没有所谓的控制权限的，c++有 
		public、private、protected
	
	c++中为什么允许函数的源码放在结构体中？因为面向对象的思想(封装的思想)。
	c++对c的结构体做了扩展，根据扩展后的机制产生了一个新的结构叫做类。

一、类的特性
class 类型名称
{
	int a;//类的成员或者叫做类的属性
	
	void fun() //类的成员函数或者叫做类的方法
	{
		
	}
};
类型名称 x;//x叫做变量名也可以叫做对象

注意:
类
{
	成员属性;
		非静态属性
		静态属性
	成员函数;
		非静态成员函数
		静态成员函数
		虚函数
}
类的属性和函数也会有控制权限:
private:修饰的成员属性或者成员方法只能被类的内部所调用，类的外部不能使用 
public:修饰的成员属性或者成员方法既可以被类的内部所调用，也可以被类的外部使用 
protected:修饰的成员属性或者成员方法只能被类的内部所调用，类的外部不能使用，只能用于继承

c++中结构体的默认访问控制权限是public
	 类的默认访问控制权限是private
一般情况下:成员属性被设置为私有的，成员方法被设置为公有的

二、什么是封装
1、就是将成员属性和成员方法集合到了一个整体中。
2、成员属性和成员方法会根据实际需求选择让不让其他的类或者对象所调用。

c++的私有属性确实需要初始化，但是初始化的功能不需要我们自定义函数，c++专门提供了一个特殊的函数叫做构造函数。


三、构造函数
功能:用来初始化属性，如果需要申请空间，也会使用到构造函数。

语法:
1、名称和类的名字一致
2、不需要任何的返回值类型，可以有参数，也可以没有参数

构造函数的分类:无参构造函数、有参构造函数、拷贝构造函数、默认构造函数(默认无参、默认拷贝)

如果我们在类中没有实现构造函数，则c++编译器会调用默认的构造函数(看不到);如果我们封装了构造函数但是没有调用则会报错(只要自己定义了构造函数，就必须调用它)。

如果调用了默认无参构造函数，则这个默认的无参构造函数的函数体为空。
如果调用了默认拷贝构造函数，则这个默认的拷贝构造函数实现的是浅拷贝。

如何使用构造函数？
无参构造函数:直接定义，定义的同时不需要传值
有参构造函数:一个参数的有参构造和多个参数的有参构造
	一个参数的:test t(1);
			   test t = 1;
			   test t = (1,2,3,4,5);
			   
	多个参数的:test t(1,2);
	构造函数可以重载(一个类中可以同时出现有参的，无参的)
	注意:如果构造函数中出现了默认参则可能出问题(二义性)

只要使用了构造函数，那么在类中几乎都会出现一个和构造函数功能相反的函数――析构函数
析构函数的特性:
1、名字和类名称相同，但是要在名称前加~
2、无任何返回值类型、没有任何参数

拷贝构造函数？
1、当一个对象给另一个对象初始化时，会调用拷贝构造函数
2、当一个对象作为函数参数传参时
3、当一个函数返回一个对象时正常也会调用拷贝构造函数
	有些环境下对拷贝构造函数的使用进行了优化。所以我们可能看不到拷贝构造函数被调用。

四、浅拷贝和深拷贝

五、堆区对象的产生
	构造函数能否私有？构造函数肯定不能私有。
	析构函数能否私有？(禁止产生栈区对象的方法)
		析构函数可以私有，但是私有后不能创建栈区对象，可以创建堆区对象。
	禁止产生堆区对象的方法？涉及到new和delete运算符的重载
	
六、静态成员变量和静态成员函数

七、this指针
class test 
{
private:
	int a;
	int b;
public:
	test(int mya,int myb)
	{
		
	}
	
	void print()
	{
		
	}
	
	static void fun()
	{
	
	}
};

main()
{
	test t(1,2);
}
		||
		\/ 
以上代码经过编译器后会发生本质的改变。
class test 
{
private:
	int a;
	int b;
};

test(test *const this,int mya,int myb)
{
	
}

void print(test *const this)
{

}

void fun()
{

}

main()
{
	test t;
	
	test(&t,1,2);
	print(&t);
	fun();
}
注意:静态成员函数没有this指针



一个函数的返回值作为一个赋值语句的左值则必须为引用；
